# Database Best Practices

## SQLModel Usage

- **Define Clear Models**: Create well-defined SQLModel classes for database tables
  ```python
  # ✅ Good: Clear model definition
  from typing import Optional
  from sqlmodel import Field, SQLModel
  from decimal import Decimal
  
  class Player(SQLModel, table=True):
      id: Optional[int] = Field(default=None, primary_key=True)
      name: str = Field(index=True)
      team: str
      player_type: str  # BAT, BOWL, ALL
      base_price: Optional[Decimal] = Field(default=None)
      sold_price: Optional[Decimal] = Field(default=None)
      season: Optional[int] = Field(default=None, index=True)
  ```

- **Use Base Models**: Create base models for common fields
  ```python
  # ✅ Good: TimeStampedModel base class
  from datetime import datetime, timezone
  
  class TimeStampedModel(SQLModel):
      created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
      updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
      
  class KagglePlayer(TimeStampedModel, table=True):
      __tablename__ = "kaggle_players"
      
      id: Optional[int] = Field(default=None, primary_key=True)
      name: str = Field(index=True)
      # Other fields...
  ```

- **Use Relationships**: Define relationships between models
  ```python
  # ✅ Good: Model relationships
  class User(SQLModel, table=True):
      id: Optional[int] = Field(default=None, primary_key=True)
      name: str
      email: str = Field(unique=True)
      
  class UserSquad(SQLModel, table=True):
      id: Optional[int] = Field(default=None, primary_key=True)
      user_id: int = Field(foreign_key="user.id")
      player_id: int = Field(foreign_key="player.id")
      is_captain: bool = False
      is_vice_captain: bool = False
  ```

## Session Management

- **Use Async Sessions**: Use async sessions for non-blocking operations
  ```python
  # ✅ Good: Async session management
  from sqlalchemy.ext.asyncio import AsyncSession
  from sqlalchemy import select
  
  async def get_player_by_id(player_id: int) -> Optional[Player]:
      async with async_session() as session:
          result = await session.execute(select(Player).where(Player.id == player_id))
          return result.scalar_one_or_none()
  ```

- **Session Factory**: Use a session factory for consistent session creation
  ```python
  # ✅ Good: Session factory
  from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
  from sqlalchemy.orm import sessionmaker
  
  async_engine = create_async_engine(DATABASE_URL, echo=True)
  async_session = sessionmaker(
      async_engine, class_=AsyncSession, expire_on_commit=False
  )
  ```

## Batch Processing

- **Process in Batches**: Handle large datasets in manageable batches
  ```python
  # ✅ Good: Batch processing
  async def process_in_batches(records: List[Dict], batch_size: int = 100):
      for i in range(0, len(records), batch_size):
          batch = records[i:i + batch_size]
          logger.info(f"Processing batch {i//batch_size + 1} ({len(batch)} records)")
          async with async_session() as session:
              # Process batch
              await session.commit()
  ```

- **Configurable Batch Size**: Allow customization of batch size
  ```python
  # ✅ Good: Configurable batch size
  async def push_integration_data(
      model_class: Type[T],
      records: List[Dict[str, Any]],
      batch_size: int = 100,
      strategy: str = "replace",
      create_table: bool = True,
  ) -> bool:
      # Process records in batches of batch_size
      for i in range(0, len(records), batch_size):
          batch = records[i:i + batch_size]
          # Process batch...
  ```

## Retry Logic

- **Implement Retry Mechanism**: Retry database operations with exponential backoff
  ```python
  # ✅ Good: Retry with exponential backoff
  async def retry_operation(
      operation: Callable[[], Any], max_retries: int = 3, backoff_factor: float = 1.5
  ) -> Any:
      retries = 0
      while retries < max_retries:
          try:
              return await operation()
          except SQLAlchemyError as e:
              retries += 1
              if retries >= max_retries:
                  raise
              await asyncio.sleep(backoff_factor ** retries)
  ```

## Integration Helpers

- **Handle Duplicates**: Efficiently handle duplicate records
  ```python
  # ✅ Good: Handle duplicates
  async def handle_duplicates(
      session: AsyncSession,
      model_class: Type[T],
      records: List[T],
      unique_fields: Optional[List[str]] = None,
  ) -> None:
      if not unique_fields:
          unique_fields = ["name"]
      
      for record in records:
          query = select(model_class)
          for field in unique_fields:
              if hasattr(record, field) and getattr(record, field) is not None:
                  query = query.where(getattr(model_class, field) == getattr(record, field))
          
          result = await session.execute(query)
          existing = result.scalar_one_or_none()
          
          if existing:
              # Update existing record
              for key, value in record.dict().items():
                  if key not in ["id"] and value is not None:
                      setattr(existing, key, value)
              session.add(existing)
          else:
              # Add new record
              session.add(record)
  ```

- **Data Transformation**: Transform data before database operations
  ```python
  # ✅ Good: Data transformation
  def transform_kaggle_data(df: pd.DataFrame) -> List[Dict[str, Any]]:
      # Rename columns to match our model
      column_mapping = {
          "Players": "name",
          "Team": "team",
          "Type": "player_type",
          "Base": "base_price",
          "Sold": "sold_price",
      }
      df = df.rename(columns=column_mapping)
      
      # Get current time with timezone
      now = datetime.now(timezone.utc)
      current_year = now.year
      
      # Process data and create records
      import_records = []
      for _, row in df.iterrows():
          import_records.append({
              "name": row.get("name", "Unknown"),
              "team": row.get("team", "TBA"),
              "player_type": row.get("player_type", "BAT"),
              "base_price": parse_price(row.get("base_price")),
              "sold_price": parse_price(row.get("sold_price")),
              "season": current_year,
              "processed": False,
              "created_at": now,
              "updated_at": now,
          })
      
      return import_records
  ```

## Query Optimization

- **Use Select Statements**: Prefer SQLModel's select statements
  ```python
  # ✅ Good: Using select statements
  from sqlmodel import select
  
  async def get_players_by_team(team: str) -> List[Player]:
      async with async_session() as session:
          statement = select(Player).where(Player.team == team)
          result = await session.execute(statement)
          return result.scalars().all()
  ```

- **Limit Query Results**: Use limit and offset for pagination
  ```python
  # ✅ Good: Pagination with limit and offset
  async def get_paginated_players(skip: int = 0, limit: int = 100) -> List[Player]:
      async with async_session() as session:
          statement = select(Player).offset(skip).limit(limit)
          result = await session.execute(statement)
          return result.scalars().all()
  ```

## Migrations

- **Use Alembic for Migrations**: Manage database schema changes with Alembic
  ```python
  # ✅ Good: Alembic configuration
  # alembic/env.py
  from sqlmodel import SQLModel
  from alembic import context
  
  # Import all models here
  from src.db.models import *
  
  target_metadata = SQLModel.metadata
  ```

- **Reset Alembic When Needed**: Clean approach for resetting migrations
  ```python
  # ✅ Good: Reset Alembic
  async def reset_alembic():
      async with async_engine.begin() as conn:
          await conn.execute(text("DROP TABLE IF EXISTS alembic_version;"))
          await conn.execute(text("CREATE TABLE alembic_version (version_num VARCHAR(32) NOT NULL);"))
  ```

- **Recreate Tables**: Sometimes a clean slate is needed
  ```python
  # ✅ Good: Recreate tables
  async def recreate_all_tables():
      async with async_engine.begin() as conn:
          # Drop all tables
          await conn.execute(text("DROP SCHEMA public CASCADE;"))
          await conn.execute(text("CREATE SCHEMA public;"))
          
          # Recreate all tables
          await conn.run_sync(SQLModel.metadata.create_all)
  ```

## Schema Validation

- **Validate Database Schema**: Check for unexpected columns
  ```python
  # ✅ Good: Validation script to check for unexpected columns
  from sqlmodel import inspect
  from sqlalchemy import create_engine
  
  engine = create_engine("sqlite:///database.db")
  inspector = inspect(engine)
  
  defined_columns = set(Player.model_fields.keys())  # Extract fields from SQLModel
  db_columns = set([col["name"] for col in inspector.get_columns("player")])
  
  unexpected_columns = db_columns - defined_columns
  if unexpected_columns:
      raise ValueError(f"Unexpected columns found in database: {unexpected_columns}")
  ```

## Indexing

- **Create Appropriate Indexes**: Add indexes for frequently queried columns
  ```python
  # ✅ Good: Adding indexes to models
  class Player(SQLModel, table=True):
      id: Optional[int] = Field(default=None, primary_key=True)
      name: str = Field(index=True)  # Add index for player name
      team: str = Field(index=True)  # Add index for team
      season: Optional[int] = Field(default=None, index=True)  # Add index for season
  ```

## Transaction Management

- **Use Transactions for Related Operations**: Ensure atomicity for related operations
  ```python
  # ✅ Good: Transaction management
  async def transfer_player(from_user_id: int, to_user_id: int, player_id: int, amount: float):
      async with async_session() as session:
          async with session.begin():
              try:
                  # Get users
                  from_user_result = await session.execute(select(User).where(User.id == from_user_id))
                  from_user = from_user_result.scalar_one()
                  
                  to_user_result = await session.execute(select(User).where(User.id == to_user_id))
                  to_user = to_user_result.scalar_one()
                  
                  # Update user balances
                  from_user.balance -= amount
                  to_user.balance += amount
                  
                  # Update player ownership
                  player_squad_result = await session.execute(
                      select(UserSquad)
                      .where(UserSquad.user_id == from_user_id)
                      .where(UserSquad.player_id == player_id)
                  )
                  player_squad = player_squad_result.scalar_one()
                  player_squad.user_id = to_user_id
                  
                  # Session will be committed automatically if no exceptions
                  return True
              except Exception as e:
                  # Session will be rolled back automatically
                  logger.error(f"Error transferring player: {str(e)}")
                  raise
  ``` 