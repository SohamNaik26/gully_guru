---
description: guide to building robust, maintainable, and performant database-driven applications with FastAPI, SQLModel, and Alembic. These practices focus on clean model design, efficient relationship management, proper API integration, and performance optimization based on real-world experience with the GullyGuru application
globs: ["**/*.py"]
alwaysApply: false
---
# Database Best Practices with FastAPI, SQLModel, and Alembic

Here are some best practices and rules you must follow:

- You use Python 3.10+
- Database frameworks:
  - SQLModel for ORM
  - Alembic for migrations
  - PostgreSQL for database
  - Pydantic for data validation
  - FastAPI for API integration
- You use async database operations
- You use SQLModel for model definitions
- You use Alembic for database migrations
- You use pytest for database testing

# SQLModel Design Patterns

sqlmodel_design_patterns = [
    "Use a TimeStampedModel base class for common fields like created_at and updated_at",
    "Add descriptive docstrings to document models with clear purpose and attributes",
    "Use Field descriptions to add metadata to fields for better documentation",
    "Define table names explicitly with __tablename__ to avoid auto-generated names",
]

# Relationship Management

relationship_management = [
    "Define relationships after all classes are defined to avoid circular references",
    "Use forward references with TYPE_CHECKING for circular dependencies",
    "Ensure relationships are bidirectional with back_populates",
    "Use link_model for many-to-many relationships",
    "Set appropriate lazy loading strategies (selectin for collections, joined for single items)",
    "Use cascade options appropriately for relationship dependencies",
]

# Computed Properties

computed_properties = [
    "Use properties for computed values that don't need to be stored in the database",
    "Attach properties to model classes after their definition",
    "Use SQLAlchemy event listeners for automatic updates (e.g., updated_at timestamps)",
    "Keep computed properties simple and focused on a single responsibility",
]

# FastAPI Integration

## Schema Design

schema_design = [
    "Create a hierarchy of schemas: Base, Create, and Response schemas",
    "Extend response schemas for specific use cases (e.g., UserResponseWithGullies)",
    "Use field validators for data validation in schemas",
    "Set model_config = ConfigDict(from_attributes=True) for ORM mode",
    "Keep schemas focused on their specific use case",
]

## Route Handlers

route_handlers = [
    "Use dependency injection for database sessions",
    "Compute complex properties in route handlers when they can't be efficiently computed at the model level",
    "Use appropriate HTTP status codes for different operations",
    "Implement proper filtering, pagination, and sorting in list endpoints",
    "Keep route handlers focused on a single responsibility",
]

# Alembic Migrations

migration_management = [
    "Use Alembic for all database schema changes",
    "Create empty migrations for relationship changes that don't affect the schema",
    "Run migrations on application startup",
    "Include all models in the Alembic configuration",
    "Use meaningful names and descriptions for migrations",
]

# Error Handling

## Custom Exceptions

custom_exceptions = [
    "Create a hierarchy of custom exceptions for different error types",
    "Use custom exceptions in route handlers for consistent error responses",
    "Include helpful error messages with specific details",
    "Set appropriate HTTP status codes for different error types",
]

## Logging

logging_practices = [
    "Use structured logging for better debugging",
    "Log all database operations in development mode",
    "Include context information in log messages",
    "Handle exceptions gracefully with appropriate error responses",
]

# Performance Optimization

## Query Optimization

query_optimization = [
    "Use eager loading to avoid N+1 query problems",
    "Use specific queries instead of loading entire objects when possible",
    "Implement pagination for list endpoints",
    "Use indexes on frequently queried fields",
    "Use select() instead of query() for more control over queries",
]

## Connection Management

connection_management = [
    "Use AsyncSession for non-blocking database operations",
    "Configure connection pooling for better performance",
    "Use context managers for session handling",
    "Implement proper error handling and rollback for failed transactions",
    "Close sessions after use to avoid resource leaks",
]

# Additional Database Guidelines

additional_database_guidelines = """
1. Always use migrations for schema changes, never modify the schema directly
2. Keep database models in a separate module from API schemas
3. Use SQLModel's relationship features instead of manual joins
4. Implement database-level constraints for data integrity
5. Use transactions for operations that modify multiple records
6. Implement proper indexing strategy for frequently queried fields
7. Use database-specific features when they provide significant benefits
8. Implement proper database connection pooling
9. Use database migrations for seeding initial data
10. Implement proper database backup and recovery procedures
"""