---
description: Guidelines for asynchronous programming and I/O operations
globs: ["**/*.py"]
---

# Asynchronous Programming Guidelines

## When to Use Async

- **I/O-Bound Operations**: Use async for operations that involve waiting for external resources:
  - Database queries
  - HTTP requests
  - File operations
  - Network operations

  ```python
  # ✅ Good: Async for I/O-bound operations
  async def get_player_data(player_id: int):
      async with httpx.AsyncClient() as client:
          response = await client.get(f"https://api.cricket.com/players/{player_id}")
      return response.json()
  ```

- **CPU-Bound Operations**: Avoid async for CPU-intensive tasks:
  ```python
  # ❌ Bad: Async for CPU-bound operations
  async def calculate_complex_statistics(data: list):
      # This doesn't benefit from async
      result = 0
      for i in range(1000000):
          result += complex_calculation(data[i % len(data)])
      return result
  
  # ✅ Better: Use a thread pool or process pool
  from concurrent.futures import ProcessPoolExecutor
  
  async def calculate_complex_statistics(data: list):
      loop = asyncio.get_event_loop()
      with ProcessPoolExecutor() as pool:
          return await loop.run_in_executor(pool, complex_calculation, data)
  ```

## Async Function Naming

- **Prefix with `get_` for Retrieval**: Use `get_` prefix for functions that retrieve data
  ```python
  async def get_player_stats(player_id: int):
      # Retrieves player stats
  ```

- **Prefix with `update_` for Modifications**: Use `update_` prefix for functions that modify data
  ```python
  async def update_player_team(player_id: int, team_id: int):
      # Updates player's team
  ```

## Error Handling in Async Code

- **Always Await Tasks**: Never ignore awaitable objects
  ```python
  # ❌ Bad: Not awaiting a coroutine
  async def process_data():
      client.get_data()  # Missing await!
  
  # ✅ Good: Properly awaiting
  async def process_data():
      await client.get_data()
  ```

- **Use Try/Except with Async**: Handle exceptions in async code
  ```python
  # ✅ Good: Exception handling in async code
  async def fetch_player_data(player_id: int):
      try:
          async with httpx.AsyncClient() as client:
              response = await client.get(f"/api/players/{player_id}")
              response.raise_for_status()
              return response.json()
      except httpx.HTTPStatusError as e:
          logger.error(f"HTTP error: {e}")
          raise HTTPException(status_code=e.response.status_code, detail="Player data fetch failed")
      except Exception as e:
          logger.error(f"Unexpected error: {e}")
          raise HTTPException(status_code=500, detail="Internal server error")
  ```

## Async Context Managers

- **Use Async Context Managers**: For resource management
  ```python
  # ✅ Good: Using async context manager
  async def get_player_data(player_id: int):
      async with httpx.AsyncClient() as client:
          response = await client.get(f"/api/players/{player_id}")
          return response.json()
  ```

## Concurrency Control

- **Use Semaphores for Limiting Concurrency**: Prevent overwhelming external services
  ```python
  # ✅ Good: Limiting concurrency
  semaphore = asyncio.Semaphore(10)  # Limit to 10 concurrent requests
  
  async def fetch_player_data(player_id: int):
      async with semaphore:
          async with httpx.AsyncClient() as client:
              return await client.get(f"/api/players/{player_id}")
  ```

- **Use `asyncio.gather` for Parallel Tasks**: Run multiple tasks concurrently
  ```python
  # ✅ Good: Parallel execution
  async def fetch_all_player_data(player_ids: list[int]):
      tasks = [fetch_player_data(player_id) for player_id in player_ids]
      return await asyncio.gather(*tasks)
  ```

## Database Operations

- **Use Async ORM**: Prefer async database libraries
  ```python
  # ✅ Good: Using async database operations
  async def get_player(player_id: int):
      async with async_session_maker() as session:
          query = select(Player).where(Player.id == player_id)
          result = await session.execute(query)
          return result.scalar_one_or_none()
  ``` 