---
description: Consistent error handling and custom exceptions
globs: ["**/*.py"]
---

# Error Handling Best Practices

## Exception Hierarchy

- **Create Custom Exception Classes**: Define domain-specific exceptions
  ```python
  # ✅ Good: Custom exception hierarchy
  class GullyGuruError(Exception):
      """Base exception for all GullyGuru errors."""
      pass
  
  class PlayerNotFoundError(GullyGuruError):
      """Raised when a player is not found."""
      pass
  
  class InsufficientBudgetError(GullyGuruError):
      """Raised when a user has insufficient budget for an operation."""
      pass
  
  class SquadLimitExceededError(GullyGuruError):
      """Raised when a user tries to exceed the squad size limit."""
      pass
  ```

## FastAPI Error Handling

- **Use HTTPException**: Raise HTTPException for API errors
  ```python
  # ✅ Good: Using HTTPException
  from fastapi import HTTPException, status
  
  @app.get("/players/{player_id}")
  async def get_player(player_id: int):
      player = await get_player_by_id(player_id)
      if player is None:
          raise HTTPException(
              status_code=status.HTTP_404_NOT_FOUND,
              detail=f"Player with ID {player_id} not found"
          )
      return player
  ```

- **Custom Error Responses**: Define consistent error response models
  ```python
  # ✅ Good: Custom error response model
  from pydantic import BaseModel
  
  class ErrorResponse(BaseModel):
      detail: str
      error_code: str
  
  @app.exception_handler(PlayerNotFoundError)
  async def player_not_found_handler(request, exc):
      return JSONResponse(
          status_code=status.HTTP_404_NOT_FOUND,
          content=ErrorResponse(
              detail=str(exc),
              error_code="PLAYER_NOT_FOUND"
          ).dict()
      )
  ```

## Try-Except Patterns

- **Be Specific with Exception Handling**: Catch specific exceptions
  ```python
  # ✅ Good: Specific exception handling
  try:
      player = get_player_by_id(player_id)
  except PlayerNotFoundError:
      # Handle player not found
  except DatabaseConnectionError:
      # Handle database connection issues
  except Exception as e:
      # Handle unexpected errors
      logger.error(f"Unexpected error: {str(e)}")
  ```

- **Don't Swallow Exceptions**: Avoid empty except blocks
  ```python
  # ❌ Bad: Swallowing exceptions
  try:
      process_player_transfer(player_id, user_id)
  except Exception:
      pass  # Don't do this!
  
  # ✅ Good: Proper exception handling
  try:
      process_player_transfer(player_id, user_id)
  except Exception as e:
      logger.error(f"Transfer failed: {str(e)}")
      raise
  ```

## Error Logging

- **Log Exceptions**: Always log exceptions with context
  ```python
  # ✅ Good: Logging exceptions with context
  import logging
  
  logger = logging.getLogger(__name__)
  
  try:
      result = process_auction_bid(user_id, player_id, bid_amount)
      return result
  except InsufficientBudgetError as e:
      logger.warning(f"User {user_id} has insufficient budget for bid: {str(e)}")
      raise HTTPException(status_code=400, detail=str(e))
  except Exception as e:
      logger.error(f"Unexpected error in auction bid: {str(e)}", exc_info=True)
      raise HTTPException(status_code=500, detail="Internal server error")
  ```

- **Include Contextual Information**: Add relevant context to error logs
  ```python
  # ✅ Good: Including context in logs
  try:
      process_squad_update(user_id, players)
  except Exception as e:
      logger.error(
          f"Squad update failed for user {user_id}",
          extra={
              "user_id": user_id,
              "players": players,
              "error": str(e)
          },
          exc_info=True
      )
  ```

## Error Recovery

- **Implement Retry Logic**: Use retries for transient failures
  ```python
  # ✅ Good: Retry logic for transient failures
  from tenacity import retry, stop_after_attempt, wait_exponential
  
  @retry(
      stop=stop_after_attempt(3),
      wait=wait_exponential(multiplier=1, min=1, max=10)
  )
  async def fetch_match_data(match_id: int):
      # This function will retry up to 3 times with exponential backoff
      async with httpx.AsyncClient() as client:
          response = await client.get(f"https://api.cricket.com/matches/{match_id}")
          response.raise_for_status()
          return response.json()
  ```

- **Graceful Degradation**: Provide fallbacks when services fail
  ```python
  # ✅ Good: Graceful degradation
  async def get_player_stats(player_id: int):
      try:
          # Try to get real-time stats
          return await fetch_realtime_player_stats(player_id)
      except APIConnectionError:
          # Fall back to cached stats if API is unavailable
          logger.warning(f"Using cached stats for player {player_id} due to API error")
          return get_cached_player_stats(player_id)
  ```

## Database Error Handling

- **Handle Database-Specific Errors**: Catch and handle database-specific exceptions
  ```python
  # ✅ Good: Database-specific error handling
  from sqlalchemy.exc import IntegrityError, OperationalError
  
  try:
      with Session(engine) as session:
          session.add(new_player)
          session.commit()
  except IntegrityError:
      # Handle constraint violations (e.g., unique constraint)
      raise HTTPException(status_code=400, detail="Player already exists")
  except OperationalError:
      # Handle database connection issues
      raise HTTPException(status_code=503, detail="Database unavailable")
  ``` 